# 9.3.2 Методы строк.

# Поиск и замена

"""
 count()
Метод count(<sub>, <start>, <end>) считает количество непересекающихся вхождений подстроки <sub> в исходную строку "s"
s = 'foo goo moo'
s.count('oo')  # 3
s.count('oo', 0, 8) # 2  (подсчет с 0 по 7 символ)


 startswith()
Метод startswith(<suffix>, <start>, <end>) определяет начинается ли исходная строка s подстрокой <suffix>.
Если исходная строка НАЧИНАЕТСЯ с подстроки <suffix>,метод возвращает значение True, а если нет, то  False.
s = 'foobar'
s.startswith('foo')  # True
s.startswith('baz')  # False


 endswith()
Метод endswith(<suffix>, <start>, <end>) определяет оканчивается ли исходная строка s подстрокой <suffix>.
Метод возвращает значение True если исходная строка ОКАНЧИВАЕТСЯ на подстроку <suffix> и False в противном случае.
s = 'foobar'
s.endswith('bar')  # True
s.endswith('baz')  # False


 find()
 rfind()
Метод find(<sub>, <start>, <end>) находит индекс первого вхождения подстроки <sub> в исходной строке "s".
Если строка "s" не содержит подстроки <sub>, то метод возвращает значение -1.
Мы можем использовать данный метод наравне с оператором in для проверки: с
одержит ли заданная строка некоторую подстроку или нет.
s = 'foo bar foo baz foo qux'
s.find('foo')  # 0
s.find('bar')  # 4
s.find('qu')  # 20
s.find('python')  # -1
Метод rfind(<sub>, <start>, <end>) идентичен методу find(<sub>, <start>, <end>), за тем исключением,
что он ищет первое вхождение подстроки <sub> начиная с конца строки "s"


 index()
 rindex()
Метод index(<sub>, <start>, <end>) идентичен методу find(<sub>, <start>, <end>), за тем исключением,
что он вызывает ошибку  ValueError: substring not found во время выполнения программы, если подстрока <sub> не найдена.

Метод rindex(<sub>, <start>, <end>) идентичен методу index(<sub>, <start>, <end>), за тем исключением,
что он ищет первое вхождение подстроки <sub> начиная с конца строки s.


 strip()
Метод strip() возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки.
s = "     foo bar foo baz foo qux      "
s.strip()  # "foo bar foo baz foo qux"


 lstrip()
Метод lstrip() возвращает копию строки s у которой удалены все пробелы стоящие в начале строки.
s = "     foo bar foo baz foo qux      "
s.lstrip()  # "foo bar foo baz foo qux      "


rstrip()
Метод rstrip() возвращает копию строки s у которой удалены все пробелы стоящие в конце строки.
s = "     foo bar foo baz foo qux      "
s.lstrip()  #  "     foo bar foo baz foo qux"


 replace()
Метод replace(<old>, <new>) возвращает копию s со всеми вхождениями подстроки <old>, замененными на <new>.
s = 'foo bar foo baz foo qux'
s.replace('foo', 'grault')  # "grault bar grault baz foo qux"


"""


# На вход программе подается строка текста, состоящая из слов, разделенных ровно одним пробелом.
# Напишите программу, которая подсчитывает количество слов в ней.
s = input()
answer = s.count(' ') + 1
print(answer)


# https://stepik.org/lesson/303083/step/9?thread=solutions&unit=284990
"""
На вход программе подается строка генетического кода, состоящая из букв А (аденин), Г (гуанин), Ц (цитозин), Т (тимин). 
Напишите программу, которая подсчитывает сколько аденина, гуанина, цитозина и тимина входит в данную строку генетического кода.

На вход программе подается строка генетического кода, состоящая из символов А, Г, Ц, Т, а, г, ц, т.
Программа должна вывести сколько гуанина, тимина, цитозина, аденина входит в данную строку генетического кода.
Примечание. Строка не содержит символов, кроме как А, Г, Ц, Т, а, г, ц, т.
"""
s = input().upper()
dna = ['Аденин:', 'Гуанин:', 'Цитозин:', 'Тимин:']
cnt = []
for el in dna:
    num = s.count(el[0])
    cnt.append(num)
for el_1, el_2 in zip(dna, cnt):
    print(str(el_1), str(el_2))

# проще
s = input().upper()
dna = ['Аденин:', 'Гуанин:', 'Цитозин:', 'Тимин:']
for el in dna:
    print(el, s.count(el[0]))


# https://stepik.org/lesson/303083/step/10?thread=solutions&unit=284990
"""
Формат входных данных
В первой строке подаётся число nn – количество сообщений, в последующих nn строках вводятся строки, 
содержащие латинские строчные буквы и цифры.

Формат выходных данных
Программа должна вывести количество строк в которых содержится число 11 минимум 3 раза.

Примечание: Числа 11 необязательно должны быть разделены другими символами, 
нужно подсчитать вхождение последовательности символов "11", т.е. 
например в строке "111" содержится одна такая последовательность, в то время как в "1111" их уже две.
"""
# решение через split()
n = int(input())
cnt = 0
for el in range(n):
    s = input()
    num = s.split('11')
    if len(num) > 3:
        cnt += 1
print(cnt)

# решение через count()
n = int(input())
cnt = 0
for el in range(n):
    s = input()
    if s.count('11') > 2:
        cnt += 1
print(cnt)


# На вход программе подается строка текста. Вывести количество цифр в данной строке.
s = input()
cnt = 0
for el in s:
    if el.isdigit():
        cnt += 1
print(cnt)

# Другие варианты
s = input()
count = 0
for el in range(10):  # "el" принимает значения от "0" до "9"
    cnt += s.count(str(el))  # подчитываем количество вхождений в строку каждого "el"
print(cnt)


# На вход программе подается строка текста.
# Напишите программу, которая проверяет, что строка заканчивается подстрокой ".com" или ".ru"
s = input()
if s.endswith('.com') or s.endswith('.ru'):
    print('YES')
else:
    print('NO')

# Другие варианты
# ('.com', '.ru') - это кортеж, значения которого последовательно перебираются в методе endswith()
print('YES' if input().endswith(('.com', '.ru')) else 'NO')

# На вход программе подается строка текста.
# Напишите программу, выводящую на экран символ, который появляется наиболее часто.
# Текст может содержать строчные и заглавные буквы английского и русского алфавита, а также цифры.
# Примечание: Если таких символов несколько, следует вывести последний по порядку символ.
s = input()
num_max = 0
letter = ''
for el in s:
    num = s.count(el)
    if num >= num_max:
        num_max = num
        letter = el
print(letter)

# Другие варианты
s = input()[::-1]  # реверс, т.к. следует вывести последний по порядку частый символ
# "max(s)" вернет символ, который имеет большее числовое значение (в таблице символов)
# "max(s, key=s.count)" вернет символ, имеющий максимальное значение указанного условия "key=s.count"
letter = max(s, key=s.count)
print(letter)


# На вход программе подается строка текста.
# Если в этой строке буква «f» встречается только один раз, выведите её индекс.
# Если она встречается два и более раза, выведите индекс её первого и последнего вхождения на одной строке,
# разделенных символом пробела. Если буква «f» в данной строке не встречается, следует вывести «NO».
s = input().lower()
if s.count('f') > 0:
    if s.count('f') < 2:
        print(s.find('f'))
    elif s.count('f') > 1:
        print(s.find('f'), s.rfind('f'))
else:
    print('NO')

# Другие варианты
s = input()
if 'f' in s:
    a = (s.find('f'))
    b = (s.rfind('f'))
    if a == b:
        print(a)
    else:
        print(a, b)
else:
    print('NO')


# На вход программе подается строка текста, в которой буква «h» встречается минимум два раза.
# Напишите программу, которая удаляет из этой строки первое и последнее вхождение буквы «h»,
# а также все символы, находящиеся между ними.
s = input()
one = s.find('h')
two = s.rfind('h') + 1
print(s[:one] + s[two:])

# Другие варианты
s = input()
one = s.find('h')
two = s.rfind('h') + 1
x = s[one:two]  # получаем фрагмент с первым и последним вхождением буквы «h» включая сами буквы
print(s.replace(x, ''))  # заменяем этот фрагмент пустой строкой ''
