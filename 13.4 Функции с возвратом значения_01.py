# 13.4 Функции с возвратом значения_01
""""""
"""
Функцию с возвратом значения пишут точно так же, как и без, но она должна иметь инструкцию return
def название_функции():
    блок кода
    return выражение
"""

# функция перевода градусов Фаренгейта в градусы Цельсия
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result

# Поскольку инструкция return возвращает значение выражения, переменную result устраняем:
def convert_to_celsius_1(temp):
    return (5 / 9) * (temp - 32)

"""
Использование нескольких return

В одной функции может быть сколько угодно инструкций return. 
Рассмотрим функцию convert_grade(), которая переводит стобалльную оценку в пятибалльную:
"""

def convert_grade(grade):
    if grade >= 90:
        return 5
    elif grade >= 80:
        return 4
    elif grade >= 70:
        return 3
    elif grade >= 60:
        return 2
    else:
        return 1

# основная программа
grade = int(input('Введите вашу отметку по 100-балльной системе: '))
print(convert_grade(grade))

"""
Функции с возвратом значения предоставляют те же преимущества, что функции без возврата значения:

упрощают программный код;
уменьшают дублирование кода;
упрощают тестирование кода;
увеличивают скорость разработки;
способствуют работе в команде.
"""


"""             Решение задач               """

"""
Задача 1. Напишите функцию, которая возвращает длину гипотенузы прямоугольного треугольника 
по известным значениям его катетов.
Примечание:
В модуле math имеется встроенная функция hypot(x, у) 
которая возвращает длину гипотенузы прямоугольного треугольника с катетами x и y
"""
def compute_hypotenuse(a, b):
    c = (a ** 2 + b ** 2) ** 0.5
    return c

"""
Напишите функцию sum_digits(n), принимающую в качестве аргумента натуральное число и возвращающую сумму его цифр.
"""
def sum_digits(n):
    result = 0
    while n > 0:
        result += n % 10
        n //= 10
    return result


"""
Напишите функцию convert_to_miles(km), 
которая принимает в качестве аргумента расстояние в километрах и возвращает расстояние в милях. 
Формула для преобразования: мили = километры * 0.6214.

Input:  print(convert_to_miles(1))
Output: 0.6214
"""

def convert_to_miles(km):
    rez = km * 0.6214
    return rez


"""
Напишите функцию get_days(month), которая принимает в качестве аргумента номер месяца и 
возвращает количество дней в данном месяце.
Примечание 1. Гарантируется, что передаваемый аргумент находится в диапазоне от 1 до 12.
Примечание 2. Считайте, что год является невисокосным.

Input:  print(get_days(1))
Output: 31
"""

def get_days(month):
    day = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    rez = day[month - 1]
    return rez

print(get_days(1))


"""
Напишите функцию get_factors(num), 
принимающую в качестве аргумента натуральное число и 
возвращающую список всех делителей данного числа.

Input:  print(get_factors(10))
Output: [1, 2, 5, 10]
"""

def get_factors(num):
    return [el for el in range(1, num + 1) if num % el == 0]

print(get_factors(10))


"""
Напишите функцию number_of_factors(num), 
принимающую в качестве аргумента число и возвращающую количество делителей данного числа.

Input:  print(number_of_factors(10))
Output: 4
"""

def number_of_factors(num):
    return len([el for el in range(1, num + 1) if num % el == 0])


"""
Напишите функцию с именем find_all(target, symbol), 
которая принимает два аргумента: строку target и символ symbol и возвращает список, 
содержащий все местоположения этого символа в строке.
Примечание: Если указанный символ не встречается в строке, то следует вернуть пустой список.

Input:  print(find_all('abcdabcaaa', 'a'))
Output: [0, 4, 7, 8, 9]
"""

def find_all(target, symbol):
    return [el for el in range(len(target)) if target[el] == symbol]


"""
Напишите функцию merge(list1, list2), 
которая принимает в качестве аргументов два отсортированных по возрастанию списка, 
состоящих из целых чисел, и объединяет их в один отсортированный список.

Примечание: Списки list1 и list2 могут иметь разную длину.

Input:  print(merge([11, 12, 10], [1, 3, 2]))
Output: [1, 2, 3, 10, 11, 12]
"""

def merge(list1, list2):
    return sorted(list1 + list2)



"""
Быстрое слияние двух отсортированных списков в один

Пусть мы имеем два уже отсортированных по возрастанию списка list1 и list2.

Алгоритм быстрого слияния следующий:

Создаем численные указатели p1 = 0 и p2 = 0 на начала обоих списков list1 и list2 соответственно;
На каждом шаге берем меньший из двух элементов list1[p1] и list2[p2];
Записываем его в результирующий список; 
Увеличиваем указатель на первый элемент списка (p1 или p2) из которого был взят элемент на 1;
Когда один из начальных списков закончился, добавляем все оставшиеся элементы второго списка в результирующий список.
"""


def quick_merge(list1, list2):
    result = []

    p1 = 0  # указатель на первый элемент списка list1
    p2 = 0  # указатель на первый элемент списка list2

    while p1 < len(list1) and p2 < len(list2):  # пока не закончился хотя бы один список
        if list1[p1] <= list2[p2]:
            result.append(list1[p1])
            p1 += 1
        else:
            result.append(list2[p2])
            p2 += 1

    if p1 < len(list1):  # прицепление остатка
        result += list1[p1:]
    if p2 < len(list2):
        result += list2[p2:]

    return result
list1 = [3, 10, 11, 12, 47, 57, 58, 63, 77, 79, 80, 95]
list2 = [0, 11, 12, 20, 24, 26, 47, 48, 53, 65, 70, 81, 84, 84, 90]
list3 = quick_merge(list1, list2)
print(list3)
# [0, 3, 10, 11, 11, 12, 12, 20, 24, 26, 47, 47, 48, 53, 57, 58, 63, 65, 70, 77, 79, 80, 81, 84, 84, 90, 95]



"""
На вход программе подается число n, а затем n строк, 
содержащих целые числа в порядке возрастания. 
Из данных строк формируются списки чисел. 
Напишите программу, которая объединяет указанные списки в один отсортированный список 
с помощью функции quick_merge(), а затем выводит его.

Input:  3
        1 2 3 4
        5 6 7
        10 11 17
Output: 1 2 3 4 5 6 7 10 11 17
"""

def quick_merge_several(num):
    list_total = []
    for _ in range(num):
        list_total += list(map(int, input().split()))
    list_total.sort()
    return list_total

n = int(input())
print(*quick_merge_several(n))

"""  Ожидаемый вариант решения:   """
# используем ранее созданную функцию
def quick_merge(list1, list2):
    result = []
    p1 = 0
    p2 = 0
    while p1 < len(list1) and p2 < len(list2):
        if list1[p1] <= list2[p2]:
            result.append(list1[p1])
            p1 += 1
        else:
            result.append(list2[p2])
            p2 += 1
    if p1 < len(list1):
        result += list1[p1:]
    if p2 < len(list2):
        result += list2[p2:]
    return result

# Само решение
list1 = []  # Начальное состояние отсортированного списка
n = int(input())
for _ in range(n):
    list2 = [int(i) for i in input().split()]  # ввод очередного списка
    list1 = quick_merge(list1, list2)  # поочередное формирование отсортированного списка
print(*list1)
